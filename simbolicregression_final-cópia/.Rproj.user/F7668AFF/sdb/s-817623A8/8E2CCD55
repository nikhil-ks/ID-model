{
    "collab_server" : "",
    "contents" : "RepLOptim <- function(parmean,parsd,fr,gr=NULL,inphess=NULL,lower=NULL,upper=NULL,\n\trethess=FALSE,parmstder=FALSE,...,control=list()) \n\n#   RepLOptim -- Repeated local optimization \n\n#   Tries to minimize a function calling local optimizers several times from different random starting points\n#   generated from multivariate normal distributions of independent variates. The standard deviations of the \n#   generating distributions are kept fixed, but their means are updated as better candidates for the global \n#   minimun are discovered\n\n#   Arguments:\n\n#   parmean   --  Vector of means for the parameter distribution generating starting points for the\n#                 local optimizer. Also used as starting point of the first call to the optimizer.\n#   parsd     --  Vector of standard deviations for the parameter distribution generating starting points \n#                 for the local optimizer. Also used as starting point of the first call to the optimizer.\n#   fr        --  The function to be minimized. If method is neither \"nlminb\" or \"L-BFGS-B\", fr should\n#                 accept a lbound and an ubound arguments for the parameter bounds, and should enforce\n#                 these bounds before calling the local optimization routine.\n#   gr        --  A function to return the gradient for the \"nlminb\", \"BFGS\", '\"CG\"'and '\"L-BFGS-B\"' methods.  \n#                 If it is 'NULL', a finite-difference approximation will be used. For the '\"SANN\"' method \n#                 it specifies a function to generate a new candidate point.  If it is 'NULL' a default Gaussian\n#                 Markov kernel is used.\n#   inphess   --  A function to return the hessian for the \"nlminb\" method. Must return a square matrix of order \n#                 'length(parmean)' with the different hessian elements in its lower triangle. \n#                 It is ignored if method component of the control list is not set to its \"nlminb\" default. \n#   lower     --  Vector of parameter lower bounds. Set to -Inf (no bounds) by default\n#   upper     --  Vector of parameter upper bounds. Set to Inf (no bounds) by default\n#   rethess   --  Bolean flag indicating wether a numerically evaluated hessian matrix at the optimum \n#                 should be computed and returned. Not available for the nlminb method.\n#   parmstder --  Bolean flag indicating wether parameter assymptotic standard errors based on the \n#                 inverse hessian approximation to the Fisher information matrix should be computed and returned.\n#                 Only available if hessian is set to \"true\" and if a local miminum with a positive-definite hessian \n#                 was indeed found. For non-trivial problems of moderate/large dimensionality this requirement often \n#                 fais because of numerical problems.\n#                 Note that the consistency of these estimates can only be assured when fr is based on a true \n#                 likelihood (as oposed to a quasi-likelihood) function\n#   ...       --  Further arguments to be passed to fr, gr or to the local optimization routine selected\n\n#  control   --  A list of control parameters that can supply any of the following components:\n#    method  --     Local optimizer to be employed. Current alternatives are:\n#                   \"nlminb\" (default) for the nlminb port routine, \"nlm\" for the nlm function and\n#                   \"Nelder-Mead\", \"L-BFGS-B\",  \"CG\", \"L-BFGS-B\" and \"SANN\" for the corresponding methods of\n#                   the optim function. \n#    maxrepet --    Maximum time of repetions of the same minimum objective value, before RepLOptim is stoped\n#                   and the current best solution is returned. By default set to 5. \n#    maxnoimprov -- Maximum number of times the local optimizer is called without improvements in the minimum \n#                   objective value, before RepLOptim is stoped and the current best solution is returned. \n#                   By default set to 25. \n#    maxreplic  --  Maximum number of times the local optimizer is called and returns a valid solution before \n#                   RepLOptim is stoped and the current best solution is returned. By default set to 250. \n#    allrep     --  Total maximum number of replications (including those leading to non-valid solutions)\n#                   performed. By default equals ten times the value of maxreplic. Ignored when objbnd is set to Inf. \n#    maxiter    --  Maximum number of iterations performed in each call to the local optimizer. By default set to 500\n#                   execept with the \"SANN\" mehtod, when by default is set to 1500. \n#    maxeval    --  maximum number of function evaluations (nlminb method only) performed in each call to \n#                   the nlminb optimizer. By defaults set to 750.\n#    RLOtol     --  The relative convergence tolerance of the local optimizer.  The local optimizer stops if it is \n#                   unable to reduce the value by a factor of ‘RLOtol *(abs(val) + reltol)’ at a step. \n#                   Ignored when method is set to \"nlm\". By default set to 1e-8.\n#    HesEgtol   --  Numerical tolerance used to ensure that the hessian is non-singular. If the last eigenvalue \n#                   of the hessian is positive but the ratio between it and the first eigenvalue is below HesEgtol, \n#                   the hessian is considered to be semi-definite and the parameter assymptotic standard errors \n#                   are not computed. By default set to 1e-8.\n#    objbnd    --   Upper bound for the objective. When different form \"Inf\" (default) only solutions leading to objective values #                   below objbnd are considered as valid.\n\n#   Value:  A list with the following components\n#\n#         par            --   The best result found for the parameter vector.\n#         val            --   The best value (minimum) found for the function fr.\n#         iterations     --   Number the iterations performed by the local optimizer in the call\n#                             that generated the best result.\n#         vallist        --   A vector with the best values found for each starting point.\n#         counts         --   Number of times the function fr was evaluated in the call that \n#                             generated the result returned.\n#         convergence    --   Code with the convergence status returned by the local optimizer.\n#         message        --   Message generated by the local optimizer.\n#         hessian        --   Numerically evaluated hessian of fr at the result returned. \n#                             Only returned when the parameter hessian is set to true. \n#         hessegval      --   Eigenvalues of the hessian matrix. Used to confirm if a local minimum was indeed found.\n#                             Only returned when the parameter hessian is set to true. \n#         stderrors      --   Assymptotic standard deviations of the parameters based on Fisher Information \n#                             matrix. Only returned when the parse parameter is set to true and the hessian is indeed\n#                             positive definite.\n\n{\n\tmethod_default <- \"nlminb\"\n\tmaxrepet_default <- 5\n\tmaxnoimprov_default <- 25\n\tmaxreplic_default <- 250\n\tmaxiter_default <- 500\n\tmaxSANNiter_default <- 1500\n\tmaxeval_default <- 750\n\tRLOtol_default <- 1e-8\n\tHesEgtol_default <- 1e-8\n \n\tif (!is.null(control$method)) method <- control$method else method <- method_default  \n\tif (!is.null(control$maxrepet)) maxrepet <- control$maxrepet else maxrepet <- maxrepet_default  \n\tif (!is.null(control$maxnoimprov)) maxnoimprov <- control$maxnoimprov else maxnoimprov <- maxnoimprov_default\n\tif (!is.null(control$maxreplic)) maxreplic <- control$maxreplic else maxreplic <- maxreplic_default\n\tif (!is.null(control$maxiter)) maxiter <- control$maxiter \n\telse if (class(method)!=\"character\") maxiter <- maxiter_default\n\t\telse if (method!=\"SANN\") maxiter <- maxiter_default\n\t\t\telse maxiter <-  maxSANNiter_default\n\tif (!is.null(control$maxeval)) maxeval <- control$maxeval else maxeval <- maxeval_default\n\tallrep <- control$allrep\n \tif (!is.null(control$RLOtol)) RLOtol <- control$RLOtol else RLOtol <- RLOtol_default  \n \tif (!is.null(control$HesEgtol)) HesEgtol <- control$HesEgtol else HesEgtol <- HesEgtol_default  \n \tif (!is.null(control$objbnd)) objbnd <- control$objbnd else objbnd <- -Inf \n \n\tif (!is.null(control$parmean)) parmean <- control$parmean \n\tif (!is.null(control$sdfactor)) \n\t\tif (!is.null(control$parsd)) parsd <- control$sdfactor * control$parsd \n \t\telse parsd <- control$sdfactor * parsd \n \telse if (!is.null(control$parsd)) parsd <- control$parsd \n \tif (!is.null(control$inphess)) inphess <- control$inphess \n \tif (!is.null(control$lower)) lower <- control$lower \n \tif (!is.null(control$upper)) upper <- control$upper \n \tif (!is.null(control$rethess)) lower <- control$rethess \n \tif (!is.null(control$parmstder)) parmstder <- control$parmstder \n \tif (!is.null(control$EnfCnstrs)) EnfCnstrs <- control$EnfCnstrs \n  \n\tnpar <- length(parmean)\n\tvalues <- NULL\n\tif (is.null(lower)) lower <- rep(-Inf,npar)\n\tif (is.null(upper)) upper <- rep(Inf,npar)\n\tif (is.finite(objbnd))  { if (is.null(allrep)) allrep <- 10*maxreplic }\n\telse allrep <- maxreplic\n\n\tbestres <- NULL\t\n\tbestval <- Inf\n\tinitpar <- bestpar <- parmean\n\tcnt <- repcnt <- noimpcnt <- 0 \n\tfor (i in 1:maxreplic)  {\n\t\tif (cnt > allrep || repcnt >= maxrepet || noimpcnt >= maxnoimprov) break\n\t\tvalue <- Inf\n\t\twhile (value >= objbnd && cnt < allrep && repcnt < maxrepet && noimpcnt < maxnoimprov)\n\t\t{\n\t\t\tif (is.function(method))\n\t\t\t\ttmpres <- method(initpar,gr=gr,lbound=lower,ubound=upper,hessian=rethess,...)\n\t\t\telse {\n\t\t\t\tif (method == \"nlminb\")\n\t\t\t\t\ttmpres <- nlminb(start=initpar,fr,gradient=gr,hessian=inphess,\n\t\t\t\t\t\tlower=lower,upper=upper,control=list(iter.max=maxiter,eval.max=maxeval),...)\n\n\t\t\t\telse if (method == \"nlm\") \n\t\t\t\t\ttmpres <- nlm(fr,p=initpar,lbound=lower,ubound=upper,iterlim=maxiter,...)\n\t\t\t\telse if (method == \"L-BFGS-B\")\n\t\t\t\t\ttmpres <- optim(initpar,fr,gr=gr,method=method,lower=lower,upper=upper,\n\t\t\t\t\t\tcontrol=list(maxit=maxiter),hessian=rethess,...)\n\t\t\t\telse if (method == \"Nelder-Mead\" || method == \"BFGS\" || method == \"CG\" || method == \"SANN\")\n\t\t\t\t\ttmpres <- optim(initpar,fr,gr=gr,method=method,control=list(maxit=maxiter),\n\t\t\t\t\t\tlbound=lower,ubound=upper,hessian=rethess,...)\n\t\t\t}\n\t\t\tif (!is.function(method))  {\n\t\t\t\tif (method == \"nlminb\") value <- tmpres$objective\n\t\t\t\telse if (method == \"nlm\") value <- tmpres$minimum\n\t\t\t\telse value<- tmpres$value\n\t\t\t}\n\t\t\telse value <- tmpres$value\n\t\t\tif (is.null(value) || is.na(value)) value <- objbnd\n\t\t\tcnt <- cnt+1\n\t\t\tvalues <- c(values,value)\n\t\t\tif (is.na(value)) { noimpcnt <- noimpcnt + 1 ; repcnt <- 0 }\n\t\t\telse {\n\t\t\t\tif (is.finite(bestval))  if (abs((value-bestval)/bestval) < RLOtol) repcnt <- repcnt + 1 \n\t\t\t\telse repcnt <- 0 \n\t\t\t\tif (value < bestval)  {\n\t\t\t\t\tbestval <- value\n\t\t\t\t\tif (is.function(method) || method != \"nlm\") bestpar <- tmpres$par\n\t\t\t\t\telse bestpar <- tmpres$estimate\n\t\t\t\t\tbestres <- tmpres\n\t\t\t\t\tnoimpcnt <- 0 \n\t\t\t\t}\n\t\t\t\telse noimpcnt <- noimpcnt + 1\n\t\t\t}\n\t\t\tif (value >= objbnd && cnt < allrep) {\n\t\t\t\tu <- runif(n=npar)     # generate npar uniform random numbers\n\t\t\t\tinitpar <- qnorm(u,mean=bestpar,sd=parsd) #  generate new parameters from a normal distribution\n\t\t\t\tlbndind <- initpar < lower   #  identify indices of parameters that fell below their lower bounds\n\t\t\t\tubndind <- initpar > upper   #  identify indices of parameters that fell above their upper bounds\n\t\t\t\tinitpar[lbndind] <- lower[lbndind] + u[lbndind] * (bestpar[lbndind]-lower[lbndind]) # and correct them\n\t\t\t\tinitpar[ubndind] <- upper[ubndind] - u[ubndind] * (upper[ubndind]-bestpar[ubndind])\n\t\t\t}\n\t\t} \n\t}\n\n\tif (!is.function(method) && method == \"nlminb\")  {\n\t\titerations <- bestres$iterations\n\t\tcounts <- bestres$evaluations\n\t\thess <- NULL\n\t\tegval <- NULL\n\t\tparstd <- NULL\n\t} \n\telse  {\n\t\titerations <- NULL\n\t\tcounts <- bestres$counts\n\t\tif (rethess==TRUE) {\n\t\t\thess <- bestres$hessian\n\t\t\tegval <- eigen(hess,symmetric=TRUE,only.values=TRUE)$values\n\t\t\tif (parmstder==TRUE)\n\t\t\t\tif (egval[npar]/egval[1] < HesEgtol)\n\t\t\t\t\tparstd <- \"Not computed because the hessian is not positive definite\"\n\t\t\t\telse parstd <- sqrt(diag(solve(hess)))\n\t\t\telse parstd <- NULL\n\t\t}\n\t\telse {\n\t\t\thess <- NULL\n\t\t\tegval <- NULL\n\t\t\tparstd <- NULL\n\t\t}\n\t} \n\tif (!is.null(bestres))\n\t\treturn( list(par=bestpar,val=bestval,iterations=iterations,vallist=values,counts=counts,\n\t\t\tconvergence=bestres$convergence,message=bestres$message,hessian=hess,hessegval=egval,stderrors=parstd) )\n\telse\n\t\treturn( list(par=NULL,val=Inf,iterations=NULL,vallist=NULL,counts=NULL,convergence=NULL,\n\t\t\tmessage=\"RepLOptim was unable to find any valid solution\",hessian=NULL,hessegval=NULL,stderrors=NULL) )\n}\n",
    "created" : 1502575507699.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3516303676",
    "id" : "8E2CCD55",
    "lastKnownWriteTime" : 1464771670,
    "last_content_update" : 1464771670,
    "path" : "D:/Users/pjmalaquias/Desktop/simbolicregression/R/RepLOptim.R",
    "project_path" : "R/RepLOptim.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}